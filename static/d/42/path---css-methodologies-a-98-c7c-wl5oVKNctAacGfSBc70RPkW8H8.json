{"data":{"site":{"siteMetadata":{"title":"Developer Notes","author":"Mark Vi"}},"markdownRemark":{"id":"a4301fda-34d1-5c2a-84b5-0b335f141f82","excerpt":"A CSS methodology is a set of guidelines for writing modular, reusable and scalable code. Although CSS is an easy language to write, without an agreed-upon…","html":"<p>A CSS methodology is a set of guidelines for writing modular, reusable and scalable code. Although CSS is an easy language to write, without an agreed-upon convention, the code gets messy almost as fast as it is written. Since each CSS declaration is defined on its own line, files get huge quickly, making them a nightmare to maintain.</p>\n<p>To solve this and other CSS implementation issues, groups of coders around the world have developed different CSS methodologies, or sets of standard practices. Each comes with its own focus, advantages and disadvantages.</p>\n<p>In this article we will take a look at the pros and cons of a few of the most popular CSS methodologies:</p>\n<h2>Object-Oriented CSS</h2>\n<blockquote>\n<p>In a nutshell: Divide layout into objects, then abstract their CSS into modules</p>\n</blockquote>\n<p>OOCSS involves identifying objects on a page and separating their structural and visual CSS styles into two declaration blocks. These blocks can then be reused by different elements, and changes need only be made in one place, leading to better consistency.</p>\n<p>Declaration blocks are applied to elements using single-class selectors to avoid specificity issues. This technique also separates content from container, so objects look the same wherever they appear. Classes also decouple mark-up from CSS. Using .title instead of h2 for heading <code class=\"language-text\">&lt;h2 class=&quot;title&quot;&gt;</code> allows it to be changed to \t<code class=\"language-text\">&lt;h3 class=&quot;title&quot;&gt;</code> without changing the CSS.</p>\n<p>To further separate HTML and CSS, class names should not include property values. A class ‘blue’ would require renaming in HTML and CSS if the colour changed.</p>\n<p>Using OOCSS a button’s CSS and markup can be defined as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.button { padding: 10px 16px; }\n.primary-skin { color: blue; }\n.secondary-skin { color: green; }\n&lt;button class=&quot;button primary-skin&quot;&gt;primary skin button&lt;/button&gt;\n&lt;button class=&quot;button secondary-skin&quot;&gt;secondary skin button&lt;/button&gt;\n&lt;div class=&quot;primary-skin&quot;&gt;primary skin div&lt;/div&gt;</code></pre></div>\n<p>OOCSS introduces many useful concepts, but its lack of rules leads to variations in interpretation that can result in inconsistencies. It has, however, been used as inspiration for stricter methodologies.</p>\n<h2>Atomic CSS</h2>\n<blockquote>\n<p>In a nutshell: Create a class selector for every repeating CSS declaration</p>\n</blockquote>\n<p>ACSS encourages developers to define single-purpose class selectors for every reusable declaration. Unlike OOCSS, which discourages CSS property values in class names, ACSS welcomes it. Using ACSS styles can be defined and applied to elements as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.mb-sm { margin-bottom: 16px; }\n.mb-lg { margin-bottom: 32px; }\n.color-blue { color: #1e90ff; }\n&lt;div class=&quot;mb-lg&quot;&gt;\n &lt;p class=&quot;mb-lg color-blue&quot;&gt;Blue text&lt;/p&gt;\n &lt;img class=&quot;mb-sm&quot; /&gt;\n&lt;/div&gt;</code></pre></div>\n<p>There are programmatic approaches to ACSS that automatically generate CSS based on classes or attributes that users add to the HTML. Atomizer is one such tool, allowing the previous HTML to be redefined as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div class=&quot;Mb(32px)&quot;&gt;\n &lt;p class=&quot;Mb(32px) C(#1e90ff)&quot;&gt;Blue text&lt;/p&gt;\n &lt;img class=&quot;Mb(16px)&quot; /&gt;\n&lt;/div&gt;</code></pre></div>\n<p>This would automatically generate the following CSS upon build:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.Mb\\(16px\\)   \n{ margin-bottom: 16px; }\n.Mb\\(32px\\)   \n{ margin-bottom: 32px; }\n.C\\(#1e90ff\\) { color: #1e90ff; }</code></pre></div>\n<p>The main benefit of ACSS is the ease of maintaining consistent code and not having to invent classes for components requiring a single CSS rule.</p>\n<p>However, ACSS used on its own can lead to an unmanageable number of classes and bloated HTML files. It is therefore  common to only use ACSS principles to create helper classes that define consistent, reusable declaration blocks.</p>\n<h2>Block Element Modifier</h2>\n<blockquote>\n<p>In a nutshell: Use a standard naming convention for classes</p>\n</blockquote>\n<p>BEM encourages developers to divide layouts into blocks and nested elements. Variations from the average appearance of a block or element should also be identified and applied using modifiers.</p>\n<p>CSS declarations are applied using a single class name of format block-name for blocks and block-name<strong>element-name for elements, with two underscores in between. Modifier names are appended to classes, prefixed with an underscore or two hyphens for better clarity, for example block-name</strong>element-name_modifer-name or block-name__element-name—modifer-name. An object is a block if it can exist without ancestors, otherwise it’s an element.</p>\n<p>Blocks can have nested blocks and elements, but elements cannot. Modifiers must be used alongside block and element classes, not instead of them.</p>\n<p>BEM can be applied to a list, where list-block—inline and list-block__item—active display lists horizontally and highlight items respectively:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;ul class=&quot;list-block list-block--inline&quot;&gt;\n&lt;li class=&quot;list-block__item&quot;&gt;Item 1&lt;/li&gt;\n &lt;li class=&quot;list-block__item&quot;&gt;Item 2&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul class=&quot;list-block&quot;&gt;\n &lt;li class=&quot;list-block__item list-block__item--active&quot;&gt;Item 1&lt;/li&gt;\n &lt;li class=&quot;list-block__item&quot;&gt;Item 2&lt;/li&gt;\n&lt;/ul&gt;</code></pre></div>\n<p>BEM is a highly effective naming convention that creates predictably behaving CSS that is easy to manage, maintain and scale. BEM does have downsides, however, including the difficulty in inventing class names for deeply nested objects, the ridiculously long class names and bloated HTML that may sometimes result, and also the lack of consistency that is caused by the inability to share CSS between objects.</p>","frontmatter":{"title":"A web designer's guide to CSS methodologies","date":"February 20, 2019"}}},"pageContext":{"slug":"/css-methodologies/","previous":{"fields":{"slug":"/gatsby/"},"frontmatter":{"title":"Gatsby JS a Static site generator"}},"next":null}}